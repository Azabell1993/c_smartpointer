# Smart Pointer Library

## 프로젝트 개요
이 프로젝트는 C 언어로 작성된 스마트 포인터 라이브러리를 구현한 것입니다. 스마트 포인터는 동적 메모리를 자동으로 관리하여 메모리 누수를 방지하고, 참조 카운트를 이용해 여러 스레드나 프로세스가 메모리를 안전하게 공유할 수 있도록 도와줍니다.

**이 프로젝트에서는 두 가지 버전의 스마트 포인터를 구현했습니다.**
1. **가변 인자를 사용하지 않는 버전**
2. **가변 인자를 사용하는 버전**

> 각 버전에서 구현된 스마트 포인터의 기능은 유사하지만, 가변 인자의 사용 여부에 따라 초기화 방식과 유연성이 달라집니다. 이 문서에서는 두 버전의 차이점과 사용 방법에 대해 설명합니다.

---

## 스마트 포인터란?

스마트 포인터는 원래 C++에서 주로 사용되는 동적 메모리 관리 개념으로, 동적으로 할당된 메모리의 수명을 관리하고 자동으로 메모리를 해제하는 역할을 합니다. 
이 프로젝트에서는 C 언어에서 이와 비슷한 기능을 구현한 **SharedPtr** (공유 스마트 포인터)와 **UniquePtr** (고유 스마트 포인터)를 제공합니다.

- **SharedPtr**: 참조 카운트를 사용하여 메모리를 공유할 수 있으며, 참조 카운트가 0이 되면 메모리가 해제됩니다.
- **UniquePtr**: 메모리의 유일한 소유자가 존재하며, 소유권 이전 후 더 이상 사용할 수 없습니다.

---

## 1. 가변 인자를 사용하지 않는 스마트 포인터

### 개요
가변 인자를 사용하지 않는 버전에서는 스마트 포인터 생성 시 고정된 인수를 사용하여 메모리를 초기화합니다. 이 방식은 초기화 시 입력되는 값이 일정한 경우에 적합합니다.

### 주요 함수 및 구조체
#### 1.1 SharedPtr 구조체
```c
typedef struct {
    void *ptr;               ///< 동적 할당된 메모리
    int *ref_count;          ///< 참조 카운트
    pthread_mutex_t *mutex;  ///< 참조 카운트를 보호하는 뮤텍스
    void (*deleter)(void*);  ///< 사용자 정의 소멸자 함수
} SharedPtr;
```
- `ptr`: 스마트 포인터가 관리하는 메모리 주소입니다.
- `ref_count`: 참조 카운트로, 해당 메모리를 참조하고 있는 객체의 수를 나타냅니다.
- `mutex`: 다중 스레드 환경에서 참조 카운트 접근뿐만 아니라, 메모리 해제에 대한 동시성 이슈도 보호합니다.
- `deleter`: 메모리를 해제할 때 사용할 소멸자 함수입니다.

#### 1.2 UniquePtr 구조체
```c
typedef struct {
    void *ptr;               ///< 동적 할당된 메모리
    void (*deleter)(void*);  ///< 사용자 정의 소멸자 함수
} UniquePtr;
```
UniquePtr은 고유한 소유권을 가지며, 참조 카운트 없이 메모리를 단독으로 관리합니다.

#### 1.3 주요 함수 요약
  1. create_shared_ptr
  ```
  SharedPtr create_shared_ptr(size_t size, void (*deleter)(void*))
  ```
  **기능:** 동적 메모리를 할당하고 참조 카운트를 관리하는 SharedPtr을 생성합니다.  
  **매개변수:**  
  - size: 할당할 메모리 크기.
  - deleter: 메모리를 해제할 소멸자 함수.
  - 리턴값: 새로운 SharedPtr 구조체.
  
  2. create_unique_ptr
  ```
  UniquePtr create_unique_ptr(size_t size, void (*deleter)(void*))
  ```
  **기능:** 고유 소유권을 가지는 UniquePtr을 생성합니다.  
  **매개변수:**  
  - size: 할당할 메모리 크기.
  - deleter: 메모리를 해제할 소멸자 함수.
  - 리턴값: 새로운 UniquePtr 구조체.

  3. retain_shared_ptr
  ```
  void retain_shared_ptr(SharedPtr *sp)
  ```
  **기능:** SharedPtr의 참조 카운트를 증가시켜 메모리가 해제되지 않도록 합니다.
  
  4. release_shared_ptr
  ```
  void release_shared_ptr(SharedPtr *sp)
  ```
  **기능:** SharedPtr의 참조 카운트를 감소시키고, 참조 카운트가 0이 되면 메모리 해제.
  
  5. release_unique_ptr
  ```
  void release_unique_ptr(UniquePtr *up)
  ```
  **기능:** UniquePtr의 소유한 메모리를 해제합니다.
  
  7. transfer_unique_ptr
  ```
  UniquePtr transfer_unique_ptr(UniquePtr *up)
  ```
  **기능:** UniquePtr의 소유권을 다른 포인터로 이전하고 기존 포인터는 NULL로 설정.
  
  7. safe_kernel_printf
  ```
  static void safe_kernel_printf(const char *format, ...)
  ```
  **기능:** 스레드 안전하게 포맷된 메시지를 출력합니다.
  
  8. kernel_errExit
  ```
  static void kernel_errExit(const char *format, ...)
  ```
  **기능:** 오류 메시지를 출력하고 프로그램을 종료합니다.
  
  9. terminate
  ```
  static void terminate(bool useExit3)
  ```
  **기능:** exit() 또는 _exit()를 사용하여 프로그램을 종료합니다.

  10. deleter  
###### Deleter 설명
    Deleter는 스마트 포인터에서 메모리를 해제할 때 사용하는 사용자 정의 소멸자 함수입니다. 기본적으로 스마트 포인터는 동적으로 할당된 메모리를 **free()**를 통해 해제하지만, 사용자 정의 소멸자 함수를 설정하면 특정 리소스 관리나 커스텀 해제 동작을 수행할 수 있습니다.
    
###### Deleter의 역할
    스마트 포인터가 더 이상 참조되지 않아 메모리를 해제할 때, deleter는 해당 메모리를 해제하는 함수로 호출됩니다.
    메모리 해제뿐만 아니라, 리소스 정리(예: 파일 닫기, 네트워크 연결 해제 등)도 수행할 수 있습니다.
    
###### Deleter 사용 방식
    `SharedPtr`과 `UniquePtr`을 생성할 때, `deleter` 함수 포인터를 인자로 넘겨줍니다. 
    deleter를 지정하지 않으면, 기본적으로 free()를 사용하여 메모리를 해제합니다.
    
    예를 들어, 파일을 열고 닫는 동작이 필요한 경우, deleter를 통해 파일을 닫는 동작을 정의할 수 있습니다.
    
##### Deleter 예시 코드
    ```
    void file_deleter(void *file_ptr) {
        fclose((FILE *)file_ptr);  // 파일 포인터를 닫음
    }
    
    SharedPtr file_ptr = create_shared_ptr(sizeof(FILE), file_deleter);
    ```
    
    이 코드는 file_deleter라는 사용자 정의 소멸자 함수를 사용하여, 파일을 다룰 때 스마트 포인터가 자동으로 파일 포인터를 닫는 역할을 하게 합니다.
  
##### Deleter를 사용하는 이유
    - `리소스 관리`: 메모리뿐만 아니라, 파일, 네트워크 소켓, 데이터베이스 연결 등 다양한 리소스를 안전하게 해제할 수 있습니다.
    - `확장성`: 기본적인 free()가 아닌, 특정 리소스에 맞는 해제 동작을 수행할 수 있도록 유연성을 제공합니다.
    - `중앙 집중화된 관리`: 메모리 해제뿐만 아니라 리소스 관리(예: 객체 파괴, 연결 해제)를 한곳에서 처리할 수 있어 코드가 간결해집니다.
    기본 Deleter (free 사용)
    ```
    void default_deleter(void *ptr) {
        free(ptr);  // 기본 메모리 해제 동작
    }
    기본적으로 스마트 포인터에서 deleter를 지정하지 않으면, default_deleter가 호출되어 malloc으로 할당된 메모리를 free로 해제합니다.

##### Deleter 사용의 장점
    - `메모리 및 리소스 관리 통합`: 동적으로 할당된 메모리뿐만 아니라 파일, 네트워크 등 다양한 리소스를 안전하게 해제할 수 있습니다.
    - `가독성 향상`: 리소스를 해제하는 코드가 스마트 포인터 내부에 캡슐화되므로, 명시적으로 해제하지 않아도 자동으로 정리됩니다.
    - `오류 예방`: 수동 메모리 해제 시 발생할 수 있는 실수나 메모리 누수를 예방할 수 있습니다.

###### 요약
  - `SharedPtr`은 참조 카운트를 기반으로 메모리를 공유하며, 참조가 0이 되면 메모리를 해제합니다.
  - `UniquePtr`은 고유 소유권을 가지며, 소유권을 이전할 수 있고 메모리를 한 번만 해제합니다.
  
  출력과 오류 처리는 스레드 안전하게 수행되며, 프로그램 종료 함수도 포함됩니다.

#### 1.4 코드 예시
```
SharedPtr sp = create_shared_ptr(sizeof(int), NULL);
*(int*)sp.ptr = 42;
retain_shared_ptr(&sp);
release_shared_ptr(&sp);
```
이 코드는 SharedPtr을 생성하고, 참조 카운트를 관리하며 메모리를 해제하는 과정입니다.


#### 1.5 가변인자가 없는 스마트 포인터의 용도
가변 인자가 없는 스마트 포인터는 고정된 인자의 초기화를 통해 스마트 포인터를 생성하고 관리하는 방식입니다. 가변 인자를 사용하지 않는다는 것은 스마트 포인터 생성 시 정해진 데이터 타입과 정해진 크기의 메모리만을 처리할 수 있다는 것을 의미합니다.

가변 인자 없는 스마트 포인터의 용도는 다음과 같이 정리할 수 있습니다.
- 고정된 데이터 타입 처리: 특정한 타입의 데이터를 동적으로 할당하고, 이를 스마트 포인터로 관리하는 데 적합합니다. 예를 들어, `int`, `float`, `char[]`와 같이 고정된 데이터 타입을 다루는 경우에 사용됩니다.
- 특정 상황에 최적화된 메모리 관리: 데이터 타입이나 초기화 방식이 고정되어 있어야 하는 시스템(예: 임베디드 시스템)에서 사용됩니다. 고정된 메모리 구조나 데이터 타입을 사용하기 때문에, 메모리 관리가 상대적으로 간단해지고 오류의 가능성이 줄어듭니다.
- 참조 카운트를 기반으로 한 메모리 해제: 가변 인자가 없는 경우에도, 스마트 포인터는 참조 카운트를 기반으로 자동으로 메모리를 관리합니다. 여러 스레드에서 동일한 리소스를 참조할 때 안전하게 사용할 수 있으며, 참조가 모두 끝나면 메모리가 해제됩니다.

#### 1.5.1 가변 인자 없는 스마트 포인터의 특징 (코드 분석)
```
SharedPtr sp = create_shared_ptr(sizeof(int), NULL);
*(int*)sp.ptr = 42;  // 값을 설정
retain_shared_ptr(&sp);  // 참조 카운트 증가
release_shared_ptr(&sp);  // 참조 카운트 감소 및 메모리 해제
```
 위의 코드를 보면, `SharedPtr`은 **고정된 데이터 타입(int)** 을 처리하는 방식으로 사용됩니다. `create_shared_ptr` 함수는 고정된 크기의 메모리(예: `sizeof(int))`를 할당하며, 그 후에는 참조 카운트를 통해 메모리를 관리합니다.

###### 가변 인자 없는 스마트 포인터의 동작 방식
- `메모리 할당`: 고정된 크기의 메모리를 할당하여 포인터가 가리키는 메모리 공간을 관리합니다.
- `참조 카운트`: `retain_shared_ptr`와 `release_shared_ptr` 함수를 통해 참조 카운트를 관리하여, 메모리가 언제 해제될지 자동으로 결정됩니다.
- `고정된 소멸자 사용`: 생성 시 전달되는 소멸자는 메모리를 해제할 때 사용되며, `NULL`인 경우 기본 소멸자인 `free()`가 사용됩니다.

----- 

### 2. 가변 인자를 사용하는 스마트 포인터
개요
가변 인자를 사용하는 버전에서는 스마트 포인터 생성 시 가변 인자를 사용하여 유연하게 초기화할 수 있습니다. 이 방식은 다양한 초기화 값을 처리할 수 있어 확장성과 재사용성이 높습니다.

##### 가변 인자의 사용 이유
가변 인자를 사용함으로써 초기화 과정에서 여러 유형의 데이터를 처리할 수 있습니다. 예를 들어, `int`, `char[]` 등 다양한 데이터 유형을 초기화 시 사용할 수 있으며, 이로 인해 코드를 보다 재사용 가능하고 유연하게 만듭니다.
초기화 뿐만이 아니라 초기화뿐만 아니라 `데이터 타입의 유연성`을 **극대화**할 수 있습니다.

### 주요 함수 및 구조체
#### 2.1 SmartPtr 구조체
```
typedef struct {
    void *ptr;               ///< 동적 할당된 메모리
    int *ref_count;          ///< 참조 카운트
    pthread_mutex_t *mutex;  ///< 참조 카운트를 보호하는 뮤텍스
} SmartPtr;
```
`SmartPtr`은 가변 인자를 사용하여 생성 시 다양한 타입의 데이터를 동적으로 초기화할 수 있습니다.

#### 2.2 주요 함수 요약
> 가변 인자를 사용하는 스마트 포인터는 다양한 데이터 타입과 초기화 값을 처리할 수 있는 유연한 메모리 관리 기능을 제공합니다. 참조 카운트와 뮤텍스를 통해 다중 스레드 환경에서도 안전하게 메모리를 관리할 수 있습니다.

  1. create_smart_ptr
  ```
  SmartPtr create_smart_ptr(size_t size, ...)
  ```
  **기능:** 가변 인자를 받아 다양한 데이터 타입에 대한 스마트 포인터를 생성합니다.  
  **매개변수:**  
  - size: 단순한 크기 정보만을 나타내지 않고, 그에 맞는 가변 인자의 데이터 타입에 따라 메모리 할당 방식이 달라집니다.
  - ...: 가변 인자를 통해 초기값을 설정.
  - 리턴값: 새로운 SmartPtr 구조체.
  
  2. retain
  ```
  void retain(SmartPtr *sp)
  ```
  **기능:** 스마트 포인터의 참조 카운트를 증가시킵니다.
  
  3. release
  ```
  void release(SmartPtr *sp)
  ```
  **기능:** 참조 카운트를 감소시키고, 참조 카운트가 0이 되면 메모리를 해제합니다.
  
  4. safe_kernel_printf
  ```
  static void safe_kernel_printf(const char *format, ...)
  ```
  **기능:** 스레드 안전하게 포맷된 메시지를 출력합니다.
  
  5. kernel_errExit
  ```
  static void kernel_errExit(const char *format, ...)
  ```
  **기능:** 오류 메시지를 출력하고 프로그램을 종료합니다.
  
  6. terminate
  ```
  static void terminate(bool useExit3)
  ```
  **기능:** 프로그램을 종료하는 함수입니다.
  
  7. kernel_socket_communication
  ```
  static void kernel_socket_communication(int sock_fd, const char *message, char *response, size_t response_size)
  ```
  **기능:** 소켓을 통해 메시지를 전송하고 응답을 받습니다.
  
  8. kernel_wait_for_process
  ```
  static void kernel_wait_for_process(pid_t pid)
  ```
  **기능:** 자식 프로세스의 종료를 기다립니다.

  10. kernel_create_thread
  ```
  static void kernel_create_thread(pthread_t *thread, void *(*start_routine)(void *), void *arg)
  ```
  **기능:** 새로운 스레드를 생성합니다.

  12. kernel_join_thread
  ```
  static void kernel_join_thread(pthread_t thread)
  ```
  **기능:** 스레드가 종료될 때까지 기다립니다.

  ###### 요약
  SmartPtr는 가변 인자를 사용해 다양한 데이터 타입을 처리할 수 있으며, 참조 카운트를 통해 메모리 관리를 자동으로 처리합니다.
  네트워크 통신, 스레드 생성 및 종료 처리 등의 기능도 포함되어 있습니다.

#### 2.3 코드 예시
```
SmartPtr int_ptr = CREATE_SMART_PTR(int, 42);  // int 포인터 초기화
SmartPtr str_ptr = CREATE_SMART_PTR(char[MAX_STRING_SIZE], "Hello, World!");  // 문자열 포인터 초기화
retain(&int_ptr);
release(&int_ptr);
```
위의 코드는 가변 인자를 사용하여 int 및 char[] 타입을 초기화하고, 참조 카운트를 관리하며 메모리를 해제하는 과정입니다.

#### 2.4 스마트 포인터(가변인자) 채팅 서버 사용 예시
가변 인자를 사용하는 스마트 포인터 활용 예시
위의 코드에서 가변 인자를 사용하는 스마트 포인터를 활용하여 클라이언트 관리 및 서버 처리 로직을 설명합니다. 이 코드는 TCP 소켓 서버를 설정하여 여러 클라이언트를 관리하고, 각 클라이언트를 스마트 포인터로 처리하여 메모리 및 리소스를 관리합니다.

##### 2.4.1. 가변 인자의 활용
가변 인자(va_list, va_start, va_arg, va_end)는 C에서 고정된 인자 대신, 여러 개의 다양한 타입과 개수의 인자를 함수로 전달할 수 있게 해줍니다. 이 코드는 TCP 서버를 여러 포트에서 실행하기 위해 가변 인자를 사용하여 여러 IP 주소와 포트를 받을 수 있도록 설계되었습니다.

```
int create_network_tcp_process(int num_tcp_proc, ...)
```
- num_tcp_proc: 서버가 생성할 TCP 프로세스(서버 인스턴스)의 수를 나타냅니다.
- ... (가변 인자): 각 서버 인스턴스에 필요한 IP 주소와 포트를 전달합니다.
이 방식의 장점은 각 서버 인스턴스의 설정(IP 주소, 포트)을 하나의 함수에서 처리할 수 있다는 것입니다. 즉, 여러 개의 서버 인스턴스를 가변 인자를 사용하여 유연하게 생성할 수 있습니다.

##### 2.4.2. 스마트 포인터와 가변 인자 사용
스마트 포인터는 클라이언트의 연결 상태와 관련된 리소스(소켓, 뮤텍스 등)를 안전하게 관리하기 위해 사용됩니다. 각 클라이언트 연결은 ClientInfo 구조체로 관리되며, create_smart_ptr()을 통해 스마트 포인터로 생성됩니다.

```
ClientInfo *client_info = (ClientInfo *)malloc(sizeof(ClientInfo));
client_info->client_fd = csock;
client_info->client_id = client_count++;
client_info->client_mutex = client_mutex;

client_infos[csock] = create_smart_ptr(client_info);
```
`ClientInfo` 구조체는 클라이언트의 소켓과 ID, 그리고 클라이언트별로 관리되는 뮤텍스를 포함합니다.
`create_smart_ptr()` 함수는 이 구조체를 스마트 포인터로 감싸서 참조 카운트 기반으로 메모리를 안전하게 관리합니다.

##### 2.4.3. 스마트 포인터(가변인자)를 사용하는 이유
스마트 포인터를 사용하는 가장 큰 이유는 메모리 관리의 안전성을 확보하기 위함입니다. 일반적으로 C에서 동적 메모리 할당(malloc)을 사용할 때는 메모리 해제(free)를 명시적으로 관리해야 하며, 여러 스레드 환경에서 리소스가 언제 해제되어야 하는지 추적하는 것이 복잡할 수 있습니다.

###### 가변인자를 활용한 스마트 포인터는 이러한 문제를 해결해 줍니다.
- `참조 카운트`: `retain()` 함수는 스마트 포인터의 참조 카운트를 증가시키고, `release()` 함수는 감소시킵니다. 참조 카운트가 0이 되면 메모리가 자동으로 해제됩니다.
- `뮤텍스 보호`: 각 클라이언트에 대한 뮤텍스를 사용하여 다중 스레드 환경에서 안전하게 리소스를 관리할 수 있습니다. 예를 들어, 클라이언트가 연결되거나 종료될 때 뮤텍스를 잠그고, 안전하게 리소스를 해제합니다.
```
retain(&client_infos[csock]);  // 스마트 포인터 참조 카운트 증가
release(&client_infos[csock]);  // 참조 카운트 감소 및 메모리 해제
```

##### 2.4.4. 서버 처리 흐름
정상적으로 사용이 가능한 코드의 주요 흐름은 다음과 같습니다.
- 서버 소켓 생성 및 바인딩: 가변 인자를 통해 전달된 IP 주소와 포트 번호를 사용하여 서버 소켓을 생성하고 바인딩합니다.
- 클라이언트 관리: 클라이언트가 연결되면 `accept()` 함수로 클라이언트 소켓을 받고, 해당 클라이언트 정보를 `ClientInfo` 구조체에 저장합니다. 스마트 포인터로 클라이언트 정보를 관리하며, 클라이언트 소켓이 닫히면 자동으로 메모리를 해제합니다.
- 뮤텍스 잠금 및 해제: 각 클라이언트마다 `뮤텍스`를 생성하여 다중 스레드 환경에서 안전하게 리소스를 보호합니다.
- 가변 인자를 활용한 유연성: 서버를 여러 IP 및 포트에서 실행할 수 있도록 가변 인자를 사용하여 초기화합니다. 이로 인해 다양한 서버 인스턴스를 유연하게 생성할 수 있습니다.

##### 2.4.5. 가변 인자와 스마트 포인터의 조합의 이점
- 유연한 초기화: 가변 인자를 통해 다양한 설정을 전달할 수 있어 서버 초기화가 유연해집니다.
- 메모리 관리 자동화: 스마트 포인터를 사용하여 참조 카운트 기반으로 메모리를 관리하고, 리소스가 더 이상 필요하지 않으면 자동으로 해제됩니다.
- 다중 스레드 안전성: 각 클라이언트 연결마다 뮤텍스를 사용하여 스레드 안전성을 확보합니다. 동시에 여러 클라이언트가 연결되어도 안전하게 소켓과 데이터를 처리할 수 있습니다.

##### 2.4.6. 결론
 이 코드는 가변 인자와 스마트 포인터를 결합하여 동적 메모리 관리와 유연한 초기화를 구현한 좋은 예입니다. 가변 인자를 통해 서버를 여러 인스턴스로 확장할 수 있으며, 스마트 포인터는 참조 카운트를 사용하여 메모리와 리소스를 자동으로 해제해 줍니다. 이를 통해 안전하고 확장 가능한 서버 코드를 구현할 수 있습니다.

---- 

### 가변 인자의 이점
여러 타입의 데이터를 초기화할 수 있어, 재사용성과 코드의 유연성이 높아집니다.
다양한 시나리오에서 동일한 `create_smart_ptr` 함수를 사용할 수 있습니다.

-----

### 두 버전의 차이점

#### 가변 인자 있는 스마트 포인터와의 차이점
##### 1. 초기화 방식의 차이
가변 인자 없는 스마트 포인터는 특정한 데이터 타입과 크기로 초기화되며, 그 데이터 타입은 함수 호출 시점에 결정됩니다.
가변 인자 있는 스마트 포인터는 다양한 타입의 데이터를 처리할 수 있으며, 초기화할 때 여러 개의 인자를 전달할 수 있습니다. 이로 인해 더 유연하게 여러 데이터 타입과 크기를 처리할 수 있습니다.
##### 2. 유연성의 차이
가변 인자 없는 버전은 고정된 데이터 타입을 처리하는 데에 적합하며, 주로 단일 데이터 타입을 처리하는 경우 유리합니다. 예를 들어, int 타입이나 특정 구조체 타입만을 처리해야 할 때는 가변 인자 없이 사용하는 것이 더 효율적일 수 있습니다.
가변 인자 있는 버전은 다양한 데이터 타입과 변수를 동적으로 처리할 수 있으며, 여러 상황에서 동일한 함수를 사용해 다양한 데이터를 처리할 수 있습니다. 예를 들어, 한 번의 함수 호출로 int, char[], double 등의 다양한 타입을 처리할 수 있습니다.
##### 3. 사용성 및 코드 복잡도
가변 인자 없는 스마트 포인터는 코드가 상대적으로 단순하며, 초기화 시 어떤 데이터를 다룰지 명확하게 알 수 있습니다. 예를 들어, create_shared_ptr(sizeof(int), NULL)와 같은 방식으로 사용됩니다.
가변 인자 있는 스마트 포인터는 보다 유연하게 초기화할 수 있지만, 그만큼 복잡한 데이터를 처리할 때 가변 인자 처리(va_list, va_start, va_arg, va_end)를 사용해야 하므로 코드의 복잡성이 증가할 수 있습니다.

------

### 차이점 요약 표
| **특징**                      | **가변 인자 없는 스마트 포인터**                             | **가변 인자 있는 스마트 포인터**                         |
|-------------------------------|-----------------------------------------------------------|--------------------------------------------------------|
| **데이터 타입**                | 고정된 데이터 타입 처리                                      | 여러 데이터 타입 처리 가능                               |
| **초기화 방식**                | 고정된 크기의 메모리 할당과 고정된 데이터 타입                | 가변 인자를 통해 다양한 크기와 데이터 타입 처리          |
| **유연성**                     | 제한적, 단일 타입 처리에 적합                                 | 매우 유연, 다양한 상황에서 사용 가능                     |
| **사용성**                     | 단순하고 간결하며 성능 최적화에 적합                    | 복잡하지만 다양한 타입 처리와 확장성 제공                         |
| **참조 카운트 관리**           | 참조 카운트로 자동 메모리 해제 관리                            | 참조 카운트로 자동 메모리 해제 관리                      |
| **적용 사례**                  | 고정된 데이터 타입의 동적 메모리 관리, 간단한 상황에 적합         | 다양한 데이터 타입을 처리할 수 있는 유연한 시스템에서 유용 |


이 방식은 코드가 단순하며, 메모리 사용을 예측 가능하게 만듭니다. 그러나 데이터 타입이 고정되므로 상황에 따라 유연성이 떨어질 수 있습니다. 따라서 유연성이 필요하지 않고, 고정된 메모리와 타입을 처리할 때 적합합니다.
